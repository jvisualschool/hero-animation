<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hero Animations Gallery</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link rel="stylesheet" href="css/gallery.css">
    <style>
        /* Override generic styles if needed */
        .card-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: var(--text-secondary);
            background: var(--bg-secondary);
        }

        .animation-card {
            cursor: pointer;
        }
    </style>
</head>

<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <a href="index.html" style="text-decoration: none;">
                    <h1 class="logo">
                        <i class="fas fa-magic"></i>
                        Hero Animations
                    </h1>
                </a>
                <button class="theme-toggle" id="themeToggle">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Hero Section -->
    <section class="hero">
        <canvas id="hero-bg-canvas"></canvas>
        <div class="container">
            <div class="hero-content">
                <div id="hero-anim-nav" class="hero-anim-nav">
                    <!-- Buttons generated by script -->
                </div>
                <h2 class="hero-title">
                    <div
                        style="display: flex; align-items: center; justify-content: center; gap: 10px; flex-wrap: wrap;">
                        16가지
                        <div class="flip-scene">
                            <div id="word-flipper" class="flip-card">
                                <div class="card-face card-front">놀라운</div>
                                <div class="card-face card-back">멋진</div>
                            </div>
                        </div>
                        히어로 애니메이션
                    </div>
                    <h3 class="hero-title-en">16 Stunning Hero Animations</h3>
                </h2>

                <style>
                    .flip-scene {
                        display: inline-block;
                        width: 160px;
                        /* Increased for wider words */
                        height: 60px;
                        /* Explicit height */
                        perspective: 1000px;
                        margin: 0 5px;
                        vertical-align: middle;
                    }

                    .flip-card {
                        width: 100%;
                        height: 100%;
                        position: relative;
                        transition: transform 0.6s cubic-bezier(0.4, 0.2, 0.2, 1);
                        transform-style: preserve-3d;
                    }

                    .flip-card.is-flipped {
                        transform: rotateX(180deg);
                    }

                    .card-face {
                        position: absolute;
                        width: 100%;
                        height: 100%;
                        -webkit-backface-visibility: hidden;
                        /* Safari */
                        backface-visibility: hidden;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: 900;
                        font-size: 2rem;
                        /* Explicit size */
                        border-radius: 12px;
                        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
                        /* Override inherited gradient text styles from .hero-title */
                        -webkit-text-fill-color: initial;
                        background-clip: initial;
                        -webkit-background-clip: initial;
                    }

                    .card-front {
                        background: var(--bg-card);
                        color: var(--text-primary);
                        border: 2px solid var(--border-color);
                    }

                    .card-back {
                        transform: rotateX(180deg);
                        background: var(--bg-card);
                        color: var(--text-primary);
                        border: 2px solid var(--border-color);
                    }
                </style>

                <script>
                    document.addEventListener('DOMContentLoaded', () => {
                        const words = [
                            "놀라운", "멋진", "아름다운", "감동적인", "눈에 띄는",
                            "환상적인", "매혹적인", "독창적인", "세련된", "다이나믹한"
                        ];
                        let index = 0;
                        const flipper = document.getElementById('word-flipper');
                        const front = flipper.querySelector('.card-front');
                        const back = flipper.querySelector('.card-back');

                        setInterval(() => {
                            if (!flipper) return;

                            // 1. Prepare Next Word on Back Face
                            const nextIndex = (index + 1) % words.length;
                            back.textContent = words[nextIndex];

                            // 2. Perform Flip
                            flipper.classList.add('is-flipped');

                            // 3. After transition, swap content and reset
                            setTimeout(() => {
                                front.textContent = words[nextIndex];
                                flipper.style.transition = 'none'; // Disable transition for instant reset
                                flipper.classList.remove('is-flipped');

                                // Force reflow
                                void flipper.offsetWidth;

                                flipper.style.transition = 'transform 0.6s'; // Re-enable transition

                                index = nextIndex;
                            }, 600); // Match transition duration

                        }, 2500);
                    });
                </script>
                <p class="hero-subtitle">인터랙티브하고 가벼운, 커스터마이징 가능한 배경 효과.</p>
                <div class="hero-features">
                    <div class="feature-item">
                        <i class="fas fa-code"></i>
                        <span>Pure CSS & JS</span>
                    </div>
                    <div class="feature-item">
                        <i class="fas fa-mobile-alt"></i>
                        <span>Responsive</span>
                    </div>
                    <div class="feature-item">
                        <i class="fas fa-copy"></i>
                        <span>Copy & Use</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Animations Gallery -->
    <section class="gallery">
        <div class="container">
            <div class="gallery-grid" id="galleryGrid">
                <!-- Cards injected here -->
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>&copy; 2026 Hero Section Animations Gallery | jvibeschool.com | Jinho Jung | </p>
        </div>
    </footer>

    <script type="module">
        const animations = [
            { id: 'particles', title: '인터랙티브 파티클', titleEn: 'Interactive Particles', desc: '마우스 커서 근처에서 연결되는 점들의 네트워크.', descEn: 'Network of points connected near the mouse cursor.' },
            { id: 'constellation', title: '별자리', titleEn: 'Constellation', desc: '신비로운 선으로 연결된 부유하는 노드들.', descEn: 'Floating nodes connected by mysterious lines.' },
            { id: 'warp', title: '워프 스피드', titleEn: 'Warp Speed', desc: '별들 사이를 고속으로 여행하는 느낌.', descEn: 'High-speed travel sensation through stars.' },
            { id: 'swirl', title: '은하수 소용돌이', titleEn: 'Galactic Swirl', desc: '중심 소용돌이로 빨려 들어가는 입자들.', descEn: 'Particles sucked into a central vortex.' },
            { id: 'dna', title: 'DNA 나선', titleEn: 'DNA Helix', desc: '회전하는 3D 이중 나선 구조.', descEn: 'Rotating 3D double helix structure.' },
            { id: 'aurora', title: '오로라', titleEn: 'Aurora Borealis', desc: '북극광을 연상시키는 부드럽게 흐르는 메시 그라디언트.', descEn: 'Smooth flowing mesh gradients resembling the Northern Lights.' },
            { id: 'fireflies', title: '반딧불이', titleEn: 'Fireflies', desc: '밤하늘에 불규칙하게 반짝이는 유기적인 입자들.', descEn: 'Organic particles blinking irregularly in the night sky.' },
            { id: 'flowfield', title: '플로우 필드', titleEn: 'Flow Field', desc: '보이지 않는 힘의 장을 따라 흐르는 입자들.', descEn: 'Particles flowing along invisible force fields.' },
            { id: 'neural', title: '신경망', titleEn: 'Neural Network', desc: '신호 펄스가 발사되는 시뮬레이션 신경 경로.', descEn: 'Simulated neural pathways with firing signal pulses.' },
            { id: 'cubes', title: '3D 큐브 필드', titleEn: '3D Cube Field', desc: '마우스에 반응하여 회전하는 부유하는 3D 큐브들.', descEn: 'Floating 3D cubes rotating in response to mouse.' },
            { id: 'tunnel', title: '무한 터널', titleEn: 'Infinite Tunnel', desc: '화면을 향해 다가오는 최면적인 3D 터널.', descEn: 'Hypnotic 3D tunnel moving towards the screen.' },
            { id: 'blobs', title: '모핑 블롭', titleEn: 'Morphing Blobs', desc: '합쳐지고 분리되는 유기적인 유동체 도형.', descEn: 'Organic fluid shapes that merge and separate.' },
            { id: 'sphere', title: '와이어프레임 구체', titleEn: 'Wireframe Sphere', desc: '회전하는 3D 지구 구조.', descEn: 'Rotating 3D globe structure.' },
            { id: 'holographic', title: '홀로그램 웨이브', titleEn: 'Holographic Waves', desc: '빛나는 미래지향적인 스캔 라인 웨이브.', descEn: 'Glowing futuristic scan line waves.' },
            { id: 'mesh', title: '그라디언트 메시', titleEn: 'Gradient Mesh', desc: '메시 그라디언트를 생성하는 부드러운 부유 블롭.', descEn: 'Soft floating blobs creating mesh gradients.' },
            { id: 'matrix_rain', title: '매트릭스 레인', titleEn: 'Matrix Rain', desc: '고전적인 디지털 코드 비 효과.', descEn: 'Classic digital code rain effect.' }
        ];

        const galleryGrid = document.getElementById('galleryGrid');
        const themeToggle = document.getElementById('themeToggle');

        // --- Hero Animation Logic ---
        const heroCanvas = document.getElementById('hero-bg-canvas');
        const heroNav = document.getElementById('hero-anim-nav');
        let currentHeroInstance = null;
        let isHeroDark = localStorage.getItem('theme') === 'dark';

        // Populate Buttons
        if (heroNav) {
            animations.forEach(anim => {
                const btn = document.createElement('button');
                btn.className = 'hero-nav-btn';
                btn.textContent = anim.title;
                btn.title = anim.title; // Tooltip for full name
                btn.dataset.id = anim.id;

                // Truncate text if too long? No, CSS handles layout.

                btn.onclick = (e) => {
                    e.stopPropagation(); // Prevent bubbling
                    loadHeroAnimation(anim.id);
                };
                heroNav.appendChild(btn);
            });
        }

        async function loadHeroAnimation(id) {
            // Update active state
            document.querySelectorAll('.hero-nav-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.querySelector(`.hero-nav-btn[data-id="${id}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            // Cleanup
            if (currentHeroInstance && currentHeroInstance.cleanup) {
                currentHeroInstance.cleanup();
            }

            // Init Canvas Size
            if (heroCanvas) {
                heroCanvas.width = heroCanvas.parentElement.offsetWidth;
                heroCanvas.height = heroCanvas.parentElement.offsetHeight;

                try {
                    const module = await import(`./js/animations/${id}.js?v=${Date.now()}`);

                    // Reset speed to default or slightly slower for background? 
                    // Most configs have good defaults.

                    currentHeroInstance = module.init(heroCanvas, isHeroDark);

                    // Ensure resize listener is active
                } catch (e) {
                    console.error("Failed to load hero animation:", e);
                }
            }
        }

        // Global Event Handlers for Hero
        window.addEventListener('resize', () => {
            // Hero Canvas Resize
            if (heroCanvas) {
                heroCanvas.width = heroCanvas.parentElement.offsetWidth;
                heroCanvas.height = heroCanvas.parentElement.offsetHeight;
                if (currentHeroInstance && currentHeroInstance.resize) {
                    currentHeroInstance.resize(heroCanvas.width, heroCanvas.height);
                }
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (currentHeroInstance && currentHeroInstance.mousemove && heroCanvas) {
                const rect = heroCanvas.getBoundingClientRect();
                // Check if mouse is roughly inside the hero section to save performance?
                // Or just always feed it relative coords.
                // Relative to canvas:
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Only send if within reasonable bounds (optional, but good for "hero" feel)
                currentHeroInstance.mousemove(x, y);
            }
        });

        // Initialize First Animation (Aurora default)
        loadHeroAnimation('aurora');


        let isDark = localStorage.getItem('theme') === 'dark';
        if (isDark) document.documentElement.setAttribute('data-theme', 'dark');

        // Observer for performance
        const observerOptions = {
            root: null,
            rootMargin: '100px',
            threshold: 0.1
        };

        const activeAnimations = new Map(); // card element -> cleanup fn

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const card = entry.target;
                const animId = card.dataset.animId;
                const canvas = card.querySelector('canvas');

                if (entry.isIntersecting) {
                    // Load Animation
                    if (!activeAnimations.has(card)) {
                        import(`./js/animations/${animId}.js`).then(module => {
                            // Resize canvas contextually
                            const rect = canvas.getBoundingClientRect();
                            canvas.width = rect.width;
                            canvas.height = rect.height;

                            // Initialize with defaults
                            const instance = module.init(canvas, isDark);

                            // FORCE VERY SLOW SPEED for Gallery Previews (1/10th of min)
                            if (module.config && module.config.speed) {
                                // Calculate ultra-slow speed
                                const minSpeed = module.config.speed.min !== undefined ? module.config.speed.min : 0.1;
                                const targetSpeed = minSpeed * 0.1;

                                // Directly update config value (ES modules are singletons, this affects the running instance)
                                module.config.speed.value = targetSpeed;

                                // Notify instance if needed
                                if (instance.updateConfig) {
                                    instance.updateConfig('speed', targetSpeed);
                                }
                            }

                            activeAnimations.set(card, instance);
                        }).catch(e => console.error(`Failed to load ${animId}`, e));
                    }
                } else {
                    // Unload Animation
                    if (activeAnimations.has(card)) {
                        const instance = activeAnimations.get(card);
                        if (instance && instance.cleanup) instance.cleanup();
                        activeAnimations.delete(card);
                        // Optional: Clear canvas
                        /*
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0,0,canvas.width, canvas.height);
                        */
                    }
                }
            });
        }, observerOptions);

        // Render Cards
        animations.forEach(anim => {
            const card = document.createElement('div');
            card.className = 'animation-card';
            card.dataset.animId = anim.id;

            // Interaction: Clicking card goes to individual page
            card.addEventListener('click', (e) => {
                window.location.href = `${anim.id}.html`;
            });

            card.innerHTML = `
                <div class="card-preview">
                    <canvas class="preview-canvas"></canvas>
                </div>
                <div class="card-content">
                    <h3 class="card-title">
                        <div>${anim.title}</div>
                        <div style="font-size: 0.7em; opacity: 0.8; font-weight: 400; margin-top: 2px;">${anim.titleEn}</div>
                    </h3>
                    <div class="card-description">
                        <div>${anim.desc}</div>
                        <div style="font-size: 0.7em; opacity: 0.8; margin-top: 4px;">${anim.descEn}</div>
                    </div>
                    <div class="card-tags">
                        <span class="tag">Canvas</span>
                        <span class="tag">Interactive</span>
                    </div>
                </div>
            `;
            galleryGrid.appendChild(card);
            observer.observe(card);
        });

        // Theme Toggle Logic
        function updateTheme() {
            // Apply to data-theme for css/gallery.css
            document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');

            // Apply classes too just in case shared styles use them
            document.documentElement.classList.toggle('dark', isDark);
            document.documentElement.classList.toggle('light', !isDark);

            themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
            localStorage.setItem('theme', isDark ? 'dark' : 'light');

            // Notify all active animations
            activeAnimations.forEach(instance => {
                if (instance.setTheme) instance.setTheme(isDark);
            });

            // Update Hero Animation
            isHeroDark = isDark;
            if (currentHeroInstance && currentHeroInstance.setTheme) {
                currentHeroInstance.setTheme(isDark);
            }
        }

        themeToggle.addEventListener('click', (e) => {
            e.stopPropagation(); // prevent clicking card underneath if button is floating? No, button is in header.
            isDark = !isDark;
            updateTheme();
        });

        updateTheme();

        // Window Resize Handler for active cards
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                activeAnimations.forEach((instance, card) => {
                    const canvas = card.querySelector('canvas');
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    if (instance.resize) instance.resize(rect.width, rect.height);
                });
            }, 100);
        });

        // Proxy mouse movement to all active visible canvases?
        // Or just let them be? 
        // Most animations use specific mouse binding.
        // We can hook `mousemove` on the card to feed local coordinates to the animation instance.
        document.querySelectorAll('.animation-card').forEach(card => {
            card.addEventListener('mousemove', (e) => {
                const instance = activeAnimations.get(card);
                if (instance && instance.mousemove) {
                    const rect = card.querySelector('canvas').getBoundingClientRect();
                    instance.mousemove(e.clientX - rect.left, e.clientY - rect.top);
                }
            });
        });

    </script>
</body>

</html>